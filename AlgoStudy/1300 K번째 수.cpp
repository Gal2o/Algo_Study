//#include <bits/stdc++.h>
//
//using namespace std;
//typedef long long ll;
//int n, answer;
//ll k;
//
//// N <= 100000
//// a[i][j] = i*j (인덱스는 1부터 시작)
//// n = 3
//// 1 2 3
//// 2 4 6
//// 3 6 9
//// B에 넣어서 오름차순 (인덱스는 1부터 시작)
//// 1 2 2 3 3 4 6 6 9 => b[7] = 6
//int main() {
//    cin >> n >> k;
//
//    // 최대 값은 k로 설정 or n*n으로 잡아도 된다
//    int st = 1, ed = k;
//
//    // 답을 구하는 로직,
//    // 어차피 오름차 순으로 정렬이 되고,
//    // b의 갯수는 N*N, 이므로, b[7]이라는 것은 어떠한 값 이하인 갯수가 7개라는 뜻
//    // 실제로 보면 1 2 2 3 3 4 6 => 6이하인 갯수가 7개다
//    // 숫자 mid 이하인 a[i][j] 갯수가 k인, 최소 X를 구하여라
//    while (st <= ed) {
//        int mid = (st + ed) / 2;
//        // 최대 100000 * 100000 이므로 long long
//        ll cnt = 0;
//
//        // i = 5라면,
//        // i 행에서 mid 보다 작은 숫자의 갯수는
//        // min(mid / i, n)
//        // mid 가 8이라면, 8보다 작거나 같은 갯수를 찾아야 한다
//        // i == 1 인 행은 1 2 3 4 5 이고, min(mid/i = 8, n = 5) 이므로 5개다
//        // i == 3 인 행은 3 6 9 12 15 이고, min(mid/i = 2, n = 5) 이므로 2개다
//        for (int i = 1; i <= n; i++) {
//            cnt += min(mid / i, n);
//        }
//
//        // mid 이하인 숫자 갯수가 k보다 작다면 mid++
//        if (cnt < k)
//            st = mid + 1;
//        else {
//            // 7개가 나오는 최소 값을 찾을때 까지 돌린다.
//            // 그 이유는 mid가 6이어도 7개, 7이어도 7개, 8이어도 7개이다.
//            // n = 3일때 7, 8은 없는 값이고, break를 한다면 오답이다.
//            ed = mid - 1;
//            answer = mid;
//        }
//    }
//
//    cout << answer << endl;
//}
////
//// Created by Mac2 on 2021/08/04.
////
//
